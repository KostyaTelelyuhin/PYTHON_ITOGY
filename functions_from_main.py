# -*- coding: utf-8 -*-
"""Functions_from_main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IGGI6db5pljA5k15aofnAexAOJ_EKm4u
"""

import math
import random
import numpy as np
import pygame
import random
import type_objects
import type_players

from pygame.locals import (
    RLEACCEL,
    KEYDOWN,
    K_SPACE,
    K_ESCAPE,
    QUIT,
)


RED = 0xFF0000
BLUE = 0x0000FF
YELLOW = 0xFFC91F
GREEN = 0x00FF00
MAGENTA = 0xFF03B8
CYAN = 0x00FFCC
BLACK = (0, 0, 0)
WHITE = 0xFFFFFF
GREY = 0x7D7D7D


g = 1
k = 1 # В будущем можно поправить, чтоб вверх ногами летало

WIDTH = 800
HEIGHT = 600
FPS = 30

screen = pygame.display.set_mode((WIDTH, HEIGHT))

def find_floor_pos(player, Rectangles):
    Floor = [3/4 * HEIGHT]
    for r in Rectangles:
        if r.y < player.y + player.a:
            continue
        if abs(r.x - player.x) >  r.l / 2:
            continue
        Floor.append(r.y - r.h)
    Floor.sort()
    return Floor[0]

def find_ceil_pos(player, Rectangles):
    Ceil = [0]
    for r in Rectangles:
        if r.y > player.y + player.a:
            continue
        if abs(r.x - player.x) >  r.l / 2:
            continue
        Ceil.append(r.y)
    Ceil.sort()
    return Ceil[-1]


def intersection(x1, y1, angle1, l1, h1, x2, y2, angle2, l2, h2):
    angle = angle1 - angle2
    x = x1 - x2
    y = y1 - y2

    if abs(x + h1 / 2 * np.cos(angle) + l1 / 2 * np.sin(angle)) < l2/2 and abs(y + h1 / 2 * np.sin(angle) - l1 / 2 * np.cos(angle)) < h2/2:
        return False
    elif abs(x - h1 / 2 * np.cos(angle) + l1 / 2 * np.sin(angle)) < l2/2 and abs(y - h1 / 2 * np.sin(angle) - l1 / 2 * np.cos(angle)) < h2/2:
        return False
    elif abs(x - h1 / 2 * np.cos(angle) - l1 / 2 * np.sin(angle)) < l2/2 and abs(y - h1 / 2 * np.sin(angle) + l1 / 2 * np.cos(angle)) < h2/2:
        return False
    elif abs(x + h1 / 2 * np.cos(angle) - l1 / 2 * np.sin(angle)) < l2/2 and abs(y + h1 / 2 * np.sin(angle) + l1 / 2 * np.cos(angle)) < h2/2:
        return False
    angle = angle2 - angle1
    x = x2 - x1
    y = y2 - y1
    if abs(x + h2 / 2 * np.cos(angle) + l2 / 2 * np.sin(angle)) < l1/2 and abs(y + h2 / 2 * np.sin(angle) - l2 / 2 * np.cos(angle)) < h1/2:
        return False
    elif abs(x - h2 / 2 * np.cos(angle) + l2 / 2 * np.sin(angle)) < l1/2 and abs(y - h2 / 2 * np.sin(angle) - l2 / 2 * np.cos(angle)) < h1/2:
        return False
    elif abs(x - h2 / 2 * np.cos(angle) - l2 / 2 * np.sin(angle)) < l1/2 and abs(y - h2 / 2 * np.sin(angle) + l2 / 2 * np.cos(angle)) < h1/2:
        return False
    elif abs(x + h2 / 2 * np.cos(angle) - l2 / 2 * np.sin(angle)) < l1/2 and abs(y + h2 / 2 * np.sin(angle) + l2 / 2 * np.cos(angle)) < h1/2:
        return False
    else:
        return True


def make_level(Level_massive):
    Triangles = []
    Rectangles = []
    Portals = []
    #Добавление всякой херни в массивы
    for i in Level_massive:
        obj = i.split(',')
        if obj[2] == 'tr':
            if len(obj) == 3:
                t = type_objects.triangle(obj[0], obj[1], screen)
                Triangles.append(t)
            elif len(obj) == 4:
                t = type_objects.triangle(obj[0], obj[1], screen, obj[3])
                Triangles.append(t)
        elif obj[2] == 'rect':
            rect = type_objects.Rectangle(obj[0], obj[1], screen, obj[3], obj[4])
            Rectangles.append(rect)

        elif obj[2] == 'portal':
            port = type_objects.Portal(obj[0], obj[1], obj[3], screen)
            Portals.append(port)
    return Triangles, Rectangles, Portals